name: $(SourceBranchName)_$(Build.SourceVersion)

trigger:
  branches:
    include:
      - main

pr: none

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Variables requeridas (configurar en Azure DevOps):
  # - DOCKER_REPOSITORY_NAME: Nombre del ACR sin .azurecr.io (ej: myregistry)
  # - DOCKER_IMAGE: Nombre de la imagen Docker
  # 
  # Service Connection requerida:
  # - AzureSubscription: Service Connection de Azure Resource Manager
  #   (Configurar en Project Settings → Service connections)

steps:
- task: PowerShell@2
  displayName: 'Generate pipeline metadata'
  continueOnError: true
  inputs:
    targetType: 'inline'
    script: |
      $fileName = "pipeline-detail.json"
      
      # Validar que package.json existe
      if (Test-Path "package.json") {
        try {
          $filePackageJsonVersion = Get-Content "package.json" | ConvertFrom-Json
          $appVersion = $filePackageJsonVersion.version
        } catch {
          Write-Warning "Error reading package.json: $_"
          $appVersion = "unknown"
        }
      } else {
        Write-Warning "package.json not found, using default version"
        $appVersion = "unknown"
      }
      
      # Crear objeto con metadata del pipeline
      $pipelineDetail = @{
        Message = "$(Build.SourceVersionMessage)"
        OwnerBranch = "$(Build.SourceVersionAuthor)"
        AppVersion = $appVersion
        CommitId = "$(Build.SourceVersion)"
        BranchName = "$(Build.SourceBranchName)"
        BuildId = "$(Build.BuildId)"
        BuildNumber = "$(Build.BuildNumber)"
      }
      
      # Convertir a JSON de forma segura
      $jsonPipelineDetail = $pipelineDetail | ConvertTo-Json -Compress
      
      # Guardar archivo
      $jsonPipelineDetail | Out-File -FilePath $fileName -Encoding utf8 -NoNewline
      
      Write-Host "Pipeline metadata generated:"
      Get-Content $fileName

- task: CopyFiles@2
  displayName: 'Copy metadata artifact'
  inputs:
    SourceFolder: '$(Build.SourcesDirectory)'
    Contents: 'pipeline-detail.json'
    TargetFolder: '$(Build.ArtifactStagingDirectory)'
    continueOnError: true

- task: PublishBuildArtifacts@1
  displayName: 'Publish metadata artifact'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)'
    ArtifactName: 'pipeline-metadata'
    publishLocation: 'Container'
    continueOnError: true

- task: AzureCLI@2
  displayName: 'Login to Azure Container Registry'
  inputs:
    azureSubscription: 'AzureSubscription' # Configurar Service Connection de Azure (recomendado)
    scriptType: 'bash'
    scriptLocation: 'inlineScript'
    inlineScript: |
      az acr login --name $(DOCKER_REPOSITORY_NAME)
      if [ $? -ne 0 ]; then
        echo "Error: Failed to login to ACR"
        exit 1
      fi
  # Alternativa si no tienes Azure Service Connection, descomenta las siguientes líneas:
  # env:
  #   AZURE_CREDENTIALS: $(AZURECR_USER):$(AZURECR_PASSWORD)

- task: Bash@3
  displayName: 'Build Docker image'
  inputs:
    targetType: 'inline'
    script: |
      echo "Building Docker image: $(DOCKER_REPOSITORY_NAME)/$(DOCKER_IMAGE)"
      docker build -t $(DOCKER_REPOSITORY_NAME)/$(DOCKER_IMAGE):$(Build.SourceVersion) \
                   -t $(DOCKER_REPOSITORY_NAME)/$(DOCKER_IMAGE):latest \
                   .
      if [ $? -ne 0 ]; then
        echo "Error: Docker build failed"
        exit 1
      fi

- task: Bash@3
  displayName: 'Push Docker image to ACR'
  inputs:
    targetType: 'inline'
    script: |
      echo "Pushing image with tags: $(Build.SourceVersion) and latest"
      docker push $(DOCKER_REPOSITORY_NAME)/$(DOCKER_IMAGE):$(Build.SourceVersion)
      docker push $(DOCKER_REPOSITORY_NAME)/$(DOCKER_IMAGE):latest
      if [ $? -ne 0 ]; then
        echo "Error: Docker push failed"
        exit 1
      fi
      echo "Image pushed successfully to ACR"